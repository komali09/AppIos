//
//  AddPolicyInteractor.swift
//  SegurosMtyiOS
//
//  Created by Israel Guti√©rrez Castillo on 17/01/18.
//  Copyright (c) 2018 IA Interactive. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import RxSwift

protocol AddPolicyBusinessLogic {
    func validatePolicy(request: AddPolicy.AddPolicyValid.Request)
    func addIndividualPolicy(request: AddPolicy.AddPolicyValid.Request)
    func addCollectivePolicy(request: AddPolicy.AddPolicyValid.Request)
    func validCertificate(certificate: String)
}

protocol AddPolicyDataStore {
    var typePolicy: PolicyType { get set }
}

class AddPolicyInteractor: AddPolicyBusinessLogic, AddPolicyDataStore {
    
    var presenter: (AddPolicyPresenter & ExpiredSessionPresentationLogic & ErrorPresentationLogic)?
    var worker: RegisterWorker?
    var disposableBag: DisposeBag = DisposeBag()
    
    var typePolicy: PolicyType = .individual
    
    
    func validatePolicy(request: AddPolicy.AddPolicyValid.Request) {
        if worker == nil {
            worker = RegisterWorker()
        }
        
        switch request.type {
        case .individual:
            typePolicy = .individual
        default:
            typePolicy = .collective
        }
        
        worker?.verifyPolicy(request.policy, certificateId: request.certicate).subscribe({ [weak self] event in
            switch event {
            case .next(_):
                let response = AddPolicy.AddPolicyValid.Response(type: request.type, error: nil)
                self?.presenter?.presentPolicyValidationSuccess(response: response)
            case .error(let error):
                let response = AddPolicy.AddPolicyValid.Response(type: request.type, error: error)
                self?.presenter?.presentPolicyValidationError(response: response)
            default:
                break
            }
        }).disposed(by: self.disposableBag)
    }
    
    func validCertificate(certificate: String) {
        worker = RegisterWorker()
        if worker?.validCertificate(certificate)  != .notValidated {
            typePolicy = .collective
        }
    }
    
    func addIndividualPolicy(request: AddPolicy.AddPolicyValid.Request) {
        if worker == nil {
            worker = RegisterWorker()
        }
        
        worker?.addIndividualPolicy(policy: request.policy).subscribe({ [weak self] event in
            switch event {
            case .next(_):
                self?.presenter?.presentAddIndividualPolicy()
            case .error(let error):
                switch error {
                case NetworkingError.unauthorized:
                    self?.presenter?.presentExpiredSession()
                default:
                    self?.presenter?.presentError(error)
                }
            default:
                break
            }
        }).disposed(by: self.disposableBag)
    }
    
    func addCollectivePolicy(request: AddPolicy.AddPolicyValid.Request) {
        if worker == nil {
            worker = RegisterWorker()
        }
        
        worker?.addCollectivePolicy(policy: request.policy, certificate: request.certicate!).subscribe({ [weak self] event in
            switch event {
            case .next(_):
                self?.presenter?.presentAddCollectivePolicy()
            case .error(let error):
                switch error {
                case NetworkingError.unauthorized:
                    self?.presenter?.presentExpiredSession()
                case NetworkingError.noSuccessStatusCode(let code, _):
                    switch code {
                    case 2:
                        self?.presenter?.presentError(VerifyCollectiveError.notValidCertificate)
                    default:
                        self?.presenter?.presentError(error)
                    }
                default:
                    self?.presenter?.presentError(error)
                }
            default:
                break
            }
        }).disposed(by: self.disposableBag)
    }
}
