//
//  PolicyCertificateViewController.swift
//  SegurosMtyiOS
//
//  Created by Isidro Adan Garcia Solorio  on 2/28/18.
//  Copyright (c) 2018 IA Interactive. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import WebKit
import Foundation
import PDFKit

protocol PolicyCertificateDisplayLogic: class {
    func displayFile(viewModel: PolicyCertificate.CertificateFile.ViewModel)
    func displayOnscreenError(type: IAErrorAlertType)
}

class PolicyCertificateViewController: UIViewController, ErrorDisplayLogic, ExpiredSessionDisplayLogic {
    var interactor: PolicyCertificateBusinessLogic?
    var router: (NSObjectProtocol & PolicyCertificateRoutingLogic & PolicyCertificateDataPassing)?
    
    @IBOutlet weak var indicatorWeb: UIActivityIndicatorView!
    @IBOutlet weak var container: UIView!
    private var webView: WKWebView?
    private var errorView:IAErrorView!
    
    private var _pdfView: UIView?
    @available(iOS 11.0, *)
    var pdfView: PDFView? {
        get {
            return _pdfView as? PDFView
        }
        set {
            _pdfView = newValue
        }
    }
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup() {
        let viewController = self
        let interactor = PolicyCertificateInteractor()
        let presenter = PolicyCertificatePresenter()
        let router = PolicyCertificateRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
  
    override func viewDidLoad() {
        super.viewDidLoad()
        if #available(iOS 11.0, *) {
            self.setupPDFView()
        } else {
            self.setupWebView()
        }
        self.loadURL()
        self.setupErrorView()
    }
    
    // MARK: Do something
    
    private func loadURL() {
        self.indicatorWeb.startAnimating()
        interactor?.getCertificate()
    }
    
    func setupWebView(){
        let webConfiguration = WKWebViewConfiguration()
        let customFrame = container.frame
        self.webView = WKWebView (frame: customFrame , configuration: webConfiguration)
        guard let webView = self.webView else { return }
        setupView(webView)
        webView.uiDelegate = self
        webView.navigationDelegate = self
    }
    
    @available(iOS 11.0, *)
    func setupPDFView() {
        let customFrame = container.frame
        pdfView = PDFView(frame: customFrame)
        guard let pdfView = self.pdfView else { return }
        setupView(pdfView)
    }
    
    func setupView(_ view:UIView) {
        view.translatesAutoresizingMaskIntoConstraints = false
        container.addSubview(view)
        view.topAnchor.constraint(equalTo: container.topAnchor).isActive = true
        view.rightAnchor.constraint(equalTo: container.rightAnchor).isActive = true
        view.leftAnchor.constraint(equalTo: container.leftAnchor).isActive = true
        view.bottomAnchor.constraint(equalTo: container.bottomAnchor).isActive = true
        view.heightAnchor.constraint(equalTo: container.heightAnchor).isActive = true
    }
    
    func setupErrorView() {
        errorView = IAErrorView(frame: CGRect(x: 0, y: 0, width: self.container.frame.width, height: self.container.frame.height) )
        errorView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        errorView.isHidden = true
        self.container.addSubview(errorView)
        
    }
   
    @IBAction func sharePressed(_ sender: UIBarButtonItem) {
        router?.routeToShare()
    }
}

extension PolicyCertificateViewController : PolicyCertificateDisplayLogic {
    func displayFile(viewModel: PolicyCertificate.CertificateFile.ViewModel) {
        self.errorView.hide()
        if #available(iOS 11.0, *) {
            indicatorWeb.stopAnimating()
            if let pdfDocument = PDFDocument(url: viewModel.fileUrl) {
                pdfView?.displayMode = .singlePageContinuous
                pdfView?.autoScales = true
                pdfView?.document = pdfDocument
            }
        } else {
            webView?.loadFileURL(viewModel.fileUrl, allowingReadAccessTo: viewModel.filePath)
        }
    }
    
    func displayOnscreenError(type: IAErrorAlertType) {
        indicatorWeb.stopAnimating()
        
        switch type {
        case .noInternet:
            errorView?.show(type: .noInternet, message: LocalizableKeys.General.noInternet, actionMessage: LocalizableKeys.General.AlertOptions.reintentar, action: {
                self.loadURL()
            })
        default:
            errorView?.show(type: .noSearchResults, message: LocalizableKeys.General.serviceError, actionMessage: LocalizableKeys.General.AlertOptions.reintentar, action: {
                self.loadURL()
            })
        }
        
    }
}

extension PolicyCertificateViewController: WKUIDelegate, WKNavigationDelegate {
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        indicatorWeb.stopAnimating()
    }
}
