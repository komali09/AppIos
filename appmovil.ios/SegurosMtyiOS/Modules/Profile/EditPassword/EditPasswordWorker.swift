//
//  EditPasswordWorker.swift
//  SegurosMtyiOS
//
//  Created by Erwin Jonnatan Perez Téllez on 28/12/17.
//  Copyright (c) 2017 IA Interactive. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import RxSwift
import SwiftyRSA

enum EditPasswordError: Error {
    case unsuccessfulEditPassword(status: EditPasswordStatus)
}

class EditPasswordWorker {

    func doSomeWork(){}

    func validatePassword(_ password: String) -> TextFieldValidationState {
        var validationState: TextFieldValidationState = .notValidated
        if password.isEmpty {
            validationState = .invalid(message: LocalizableKeys.Profile.EditPassword.errorEmptyPassword)
        } else
            if Util.validatePassword(password) {
                validationState = .valid(message: "") //formato de actual password válido
            } else {
                validationState = .invalid(message: LocalizableKeys.Login.invalidPassword)
        }
        return validationState
    }
    
    func validateBothPasswordString(_ passwordString: String, repeatedPasswordString: String) -> TextFieldValidationState {
        var validationState: TextFieldValidationState = .notValidated
        
        if passwordString == repeatedPasswordString {
            validationState = .valid(message: "")
        } else {
            validationState = .invalid(message: "Las contraseñas ingresadas no coinciden. Por favor verifica.")
        }
        return validationState
    }
    
    func changePassword(_ oldPassword: String, newPassword: String) -> Observable<Bool> {
        
        if oldPassword.isEmpty || newPassword.isEmpty {
            return Observable.error(WorkerError.noInput)
        }

        guard let encryptedOldPassword = CryptoManager.rsaString(publicKey: UserDefaultsManager.shared.publicKeyToCipherRSA, value: oldPassword) else {
            return Observable.error(WorkerError.noPublicKey)
        }
        
        guard let encryptedNewPassword = CryptoManager.rsaString(publicKey: UserDefaultsManager.shared.publicKeyToCipherRSA, value: newPassword) else {
            return Observable.error(WorkerError.noPublicKey)
        }
        
        return Observable.create { observable in
            
            let disposable = ServiceManager.changePassword(oldPassword: encryptedOldPassword, newPassword: encryptedNewPassword).subscribe{ event in
                switch event {
                case .next(let result):
                    observable.onNext(result)
                case .error(let error):
                    
                    let status = self.getChangePasswordErrorStatus(with: error)
                    observable.onError(EditPasswordError.unsuccessfulEditPassword(status: status))
                
                case .completed:
                    break
                }
            }
            return Disposables.create {
                disposable.dispose()
            }
        }
    }
    
    
    private func getChangePasswordErrorStatus(with error:Error) -> EditPasswordStatus {
        var status: EditPasswordStatus = .other(message: LocalizableKeys.General.serviceError)
        switch error {
        case NetworkingError.noSuccessStatusCode(let code, let body):
            switch code {
            case 1:
                status = .invalidPassword(reattempsLeft: body.rattempts ?? 0, message: String(format: LocalizableKeys.Login.invalidLoginPassword, body.rattempts ?? 0))
            case 3:
                status = .unauthorized(message: LocalizableKeys.General.expiredSession)
            default:
                status = .other(message: "No se pudo cambiar la contraseña. Intenta nuevamente.")
                break
            }
        case NetworkingError.unauthorized:
            status = .unauthorized(message: LocalizableKeys.General.expiredSession)
        case NetworkingError.noInternet:
            status = .noInternet(message: LocalizableKeys.General.noInternet)
        default:
            break
        }
        return status
    }

    
}
