//
//  EditPasswordInteractor.swift
//  SegurosMtyiOS
//
//  Created by Erwin Jonnatan Perez TÃ©llez on 28/12/17.
//  Copyright (c) 2017 IA Interactive. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import RxSwift

protocol EditPasswordBusinessLogic {
    func doSomething(request: EditPassword.Something.Request)
    func changePassword(_ oldPassword: String, newPassword: String, attemptNewPassword: String)
    
    
    func validateOldPassword(_ attemptOfOriginalPassword: String)
    func validateNewPassword(_ password: String)
    func validateRepeatedNewPassword(_ password: String, repeatedPassword: String)
}

protocol EditPasswordDataStore {
    //var myDataStoreVar: String { get set }
}

class EditPasswordInteractor: EditPasswordBusinessLogic, EditPasswordDataStore {
    var presenter: (EditPasswordPresentationLogic & ExpiredSessionPresentationLogic & ErrorPresentationLogic)?
    var worker: EditPasswordWorker? = EditPasswordWorker()
    var disposableBag: DisposeBag = DisposeBag()
    
    func doSomething(request: EditPassword.Something.Request) {
        worker = EditPasswordWorker()
        worker?.doSomeWork()
        
        let response = EditPassword.Something.Response()
        presenter?.presentSomething(response: response)
    }
    
    func validateOldPassword(_ attemptOfOriginalPassword: String) {
        let validationState = worker?.validatePassword(attemptOfOriginalPassword) ?? .notValidated
        presenter?.showMessageForValidatingOldPassword(validationState: validationState)
    }
    
    func validateNewPassword(_ password: String) {
        let validationState = worker?.validatePassword(password) ?? .notValidated
        presenter?.showMessageForValidatingNewPassword(validationState: validationState)
    }
    
    func validateRepeatedNewPassword(_ password: String, repeatedPassword: String) {
        let validationState = worker?.validateBothPasswordString(password, repeatedPasswordString: repeatedPassword) ?? .notValidated
        presenter?.showMessageForRepeatPassword(validationState: validationState)
    }
    
    func changePassword(_ oldPassword: String, newPassword: String, attemptNewPassword: String) {
        
        let validateNewPassword = worker?.validatePassword(newPassword) ?? .notValidated
        let validateOldPassword = worker?.validatePassword(oldPassword) ?? .notValidated
        let validateBothNewPassword = worker?.validateBothPasswordString(newPassword, repeatedPasswordString: attemptNewPassword) ?? .notValidated
    
        switch (validateNewPassword, validateOldPassword, validateBothNewPassword) {
        case (.valid, .valid, .valid):
            worker?.changePassword(oldPassword, newPassword: newPassword).subscribe({ [weak self] event in
                
                var resultError: Error? = nil
                
                switch event {
                case .next(_):
                    self?.presenter?.successfullPasswordUpdate()
                    
                case .error(let error):
                    resultError = error
                    debugPrint(error)
                    
                default:
                    break
                }
                
                if resultError != nil {
                    self?.presenter?.presentError(resultError!)
                }
 
                
            }).disposed(by: self.disposableBag)
        default:
            IALoader.shared.hide()
            presenter?.showMessageForValidatingOldPassword(validationState: validateOldPassword)
            presenter?.showMessageForValidatingNewPassword(validationState: validateNewPassword)
            presenter?.showMessageForRepeatPassword(validationState: validateBothNewPassword)
        }
    }
}
