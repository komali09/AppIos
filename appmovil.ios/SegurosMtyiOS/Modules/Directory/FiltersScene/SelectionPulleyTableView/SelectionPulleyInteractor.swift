//
//  SelectionPulleyInteractor.swift
//  SegurosMtyiOS
//
//  Created by Erwin Jonnatan Perez Téllez on 20/12/17.
//  Copyright (c) 2017 IA Interactive. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import RxSwift

protocol SelectionPulleyBusinessLogic {
    func getStates()
    func filterItems(by searchText: String)
    func getDoctorSpecialities()
}

protocol SelectionPulleyDataStore {
    var selectedState: State? { get set }
}

/**
 Clase que muestra la lista de estados o especialidaes para agregar a los filtros de ubicaciones
 */
class SelectionPulleyInteractor: SelectionPulleyBusinessLogic, SelectionPulleyDataStore {
    var presenter: (SelectionPulleyPresentationLogic & ExpiredSessionPresentationLogic & ErrorPresentationLogic)?
    var worker: FiltersWorker?
    
    var typeSelection: typeSelectionFilters = .none
    var states: [State]?
    var selectedState: State?
    var specialities: [Specialty]?
    
    // MARK: DataStore
    var disposableBag: DisposeBag = DisposeBag()
    
    // MARK: Do something
    
    /**
     Método que obtiene la lista de estados disponibles
     */
    func getStates() {
        if worker == nil {
            worker = FiltersWorker()
        }
        worker?.getStates().subscribe({ event in
            switch event {
            case .next(let result):
                self.states = result
                self.typeSelection = .states
                let response = SelectionPulley.States.Response(states: result)
                self.presenter?.presentStates(response: response)
            case .error(let error):
                switch error {
                case NetworkingError.unauthorized:
                    self.presenter?.presentExpiredSession()
                default:
                    self.presenter?.presentError(error)
                }
            default:
                break
            }
            
        }).disposed(by: self.disposableBag)
    }
    
    /**
     Método que realiza un filter al arreglo de estados por un string que contenga el nombre del estado
     */
    func filterItems(by searchText: String) {
        if worker == nil {
            worker = FiltersWorker()
        }
        
        if self.typeSelection == .states {
            if self.states == nil {
                return
            }
        } else {
            if self.specialities == nil {
                return
            }
        }
        
        switch self.typeSelection {
        case .states:
            let statesFiltered = worker?.filterStates(by: searchText, states: self.states!)
            let response = SelectionPulley.FilterStates.Response(states: (statesFiltered!.count > 0 ? statesFiltered : [State]())!)
            self.presenter?.presentFilteredStates(response: response)
        default:
            let specialitiesFiltered = worker?.filterSpecialities(by: searchText, specialties: self.specialities!)
            let response = SelectionPulley.FilterSpecialities.Response(specialities: (specialitiesFiltered!.count > 0 ? specialitiesFiltered : [Specialty]())!)
            self.presenter?.presentFilteredSpecialities(response: response)
        }
    }
    
    /**
     Método que obtiene la lista de especialidades de doctores disponibles
     */
    func getDoctorSpecialities() {
        if worker == nil {
            worker = FiltersWorker()
        }
        worker?.getDoctorSpecialities().subscribe({ event in
            switch event {
            case .next(let result):
                self.specialities = result
                self.typeSelection = .specialities
                let response = SelectionPulley.DoctorSpecialities.Response(specialities: result)
                self.presenter?.presentSpecialities(response: response)
            case .error(let error):
                switch error {
                case NetworkingError.unauthorized:
                    self.presenter?.presentExpiredSession()
                default:
                    self.presenter?.presentError(error)
                }
            default:
                break
            }
            
        }).disposed(by: self.disposableBag)
    }
}
