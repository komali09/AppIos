//
//  CheckCodeWorker.swift
//  SegurosMtyiOS
//
//  Created by Erwin Jonnatan Perez Téllez on 07/12/17.
//  Copyright (c) 2017 IA Interactive. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import RxSwift

class CheckCodeWorker {
    //getServerTimestamp()
    
    /**
     Realiza la petición para validar e iniciar el proceso de recuperar contraseña
     - parameter phoneNumber: Número de teléfono del usuario
     */
    func generateCodeToRecoverPassword(_ phoneNumber:String) -> Observable<GenerateCodeResponse> {
        if phoneNumber.count == 0 {
            return Observable.error(WorkerError.noInput)
        }  else {
            return Observable.create { observable in
                let disposable = ServiceManager.generateCodeRecoverPassword(phoneNumber: phoneNumber)
                    .catchError{ error in self.getServerTimestamp(with: error) }
                    .subscribe { event in
                    switch event {
                    case .next(let result):
                        observable.onNext(result)
                    case .error(let error):
                        observable.onError(error)
                    default:
                        break
                    }
                }
                
                return Disposables.create {
                    disposable.dispose()
                }
            }
        }
    }
    
    /**
     Realiza la petición para obtener la llave publica del servidor
     - parameter phoneNumber: Número de teléfono del usuario
     */
    func generateCodeToActiveAccount(_ phoneNumber:String) -> Observable<GenerateCodeResponse> {
        if phoneNumber.count == 0 {
            return Observable.error(WorkerError.noInput)
        }  else {
            return Observable.create { observable in
                let disposable = ServiceManager.generateCodeToActiveAccount(phoneNumber: phoneNumber)
                    .catchError{ error in self.getServerTimestamp(with: error) }
                    .subscribe { event in
                    switch event {
                    case .next(let result):
                        observable.onNext(result)
                    case .error(let error):
                        observable.onError(error)
                    default:
                        break
                    }
                }
                return Disposables.create {
                    disposable.dispose()
                }
            }
        }
    }
    
    func getServerTimestamp(with error:Error) -> Observable<GenerateCodeResponse> {
        return Observable.create { observable in
            let disposable = ServiceManager.getServerTimestamp().subscribe { event in
                switch event {
                case .next(let result):
                    let response = GenerateCodeResponse(timestamp: result)
                    observable.onNext(response)
                default:
                    break
                }
                observable.onError(error)
            }
            return Disposables.create {
                disposable.dispose()
            }
        }
    }
    
    /**
     Realiza la validación de la codigo recibido
     - parameter code: codigo a validar.
     */
    func validateCode(_ code:String) -> TextFieldValidationState {
        if code.count == 6 {
            return .valid(message: "")
        } else if code.isEmpty {
            return .invalid(message: LocalizableKeys.RecoverPassword.emptyCode)
        } else {
            return .invalid(message: LocalizableKeys.RecoverPassword.invalidCode)
        }
    }
    
    /**
     Realiza la petición para verificar el código ingresado
     - parameter phoneNumber: Número de teléfono del usuario
     - parameter code: Código ingresado por el usuario
     */
    func verifyCode(_ phoneNumber:String, code: String, timestamp: Int?, validationCodeProccessType: ValidationCodeProccessType) -> Observable<VerifyCodeResponse> {
        let timestamp = timestamp ?? Int(Date().timeIntervalSince1970) * 1000
        guard let totpCode = CryptoManager.generateTOTP(for: code, timestamp: UInt64(timestamp)) else { return Observable.error(WorkerError.noPublicKey) }
        
        return Observable.create { observable in
            let disposable = ServiceManager.verifyCodeSMS(phoneNumber: phoneNumber, code: code, totpCode: totpCode, validationCodeProccessType: validationCodeProccessType).subscribe { event in
                switch event {
                case .next(let result):
                    observable.onNext(result)
                case .error(let error):
                    observable.onError(error)
                case .completed:
                    break
                }
            }
            return Disposables.create {
                disposable.dispose()
            }
        }
    }
}
