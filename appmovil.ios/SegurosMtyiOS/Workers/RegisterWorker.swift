//
//  FormSceneWorker.swift
//  SegurosMtyiOS
//
//  Created by Claudia Mariana Parente Ramos on 18/01/18.
//  Copyright (c) 2018 IA Interactive. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import RxSwift
import SwiftyRSA

enum TypeName {
    case name
    case firtsName
    case secondName
}

class RegisterWorker {
    
    func verifyPolicy(_ policyId: String, certificateId: String?) -> Observable<Bool> {
        var certificateId: String? = certificateId
        if certificateId?.isEmpty ?? false {
            certificateId = nil
        }
        return Observable.create { observable in
            let disposable = ServiceManager.verifyPolicyRegister(policy: policyId, certificate: certificateId).subscribe({ event in
                switch event {
                case .next(let result):
                    UserDefaultsManager.shared.publicKeyToCipherRSA = result.publicKey
                    observable.onNext(true)
                case .error(let error):
                    observable.onError(error)
                case .completed:
                    break
                }
            })
            return Disposables.create {
                disposable.dispose()
            }
        }
    }
    
    func validatePassword(_ password: String) -> TextFieldValidationState {
        if password.isEmpty {
            return .invalid(message: LocalizableKeys.Login.emptyPassword)
        }
        if Util.validatePassword(password) {
            return .valid(message: "")
        } else {
            return .invalid(message: LocalizableKeys.Login.invalidPassword)
        }
    }
    
    func validateBothPasswordString(_ passwordString: String, repeatedPasswordString: String) -> TextFieldValidationState {
        if passwordString == repeatedPasswordString {
            return .valid(message: "")
        } else {
            return .invalid(message: "Las contraseñas ingresadas no coinciden. Por favor verifica.")
        }
        
    }
    
    func validateName(_ name: String , type: TypeName) -> TextFieldValidationState {
        if Util.validateName(name) {
            return .valid(message: "")
        } else {
            switch type{
            case .name:
                return .invalid(message: name.isEmpty ? LocalizableKeys.Register.name : LocalizableKeys.Profile.EditProfile.errorNameInvalid)
            case .firtsName:
                return .invalid(message:LocalizableKeys.Register.firtsName)
            case .secondName:
                return .notValidated
            }
        }
    }
    
    func validatePhone(_ phone: String ) -> TextFieldValidationState {
        if Util.validatePhoneNumberLength(phone) {
            return .valid(message: "")
        } else {
            return .invalid(message: phone.isEmpty ? LocalizableKeys.Register.phone : LocalizableKeys.Login.invalidNumber)
        }
    }
    
    func validateMail(_ mail: String ) -> TextFieldValidationState {
        if Util.validateEmail(mail) {
            return .valid(message: "")
        } else {
            return .invalid(message: mail.isEmpty ? LocalizableKeys.Register.mail : LocalizableKeys.Register.invalidMail)
        }
    }
    
    func register(name: String, fatherLastName: String, motherLastName: String?, email: String, phone: String, password: String, date: Date, policyId: String, certificateId: String?) -> Observable<Bool> {
        IALoader.shared.show("Realizando registro")
        guard let encryptedPassword = CryptoManager.rsaString(publicKey: UserDefaultsManager.shared.publicKeyToCipherRSA, value: password) else { return Observable.error(WorkerError.noPublicKey) }
        
        return Observable.create { observable in
            let dateString = date.longDate()
            let disposable = ServiceManager.register(name: name, fatherLastName: fatherLastName, motherLastName: motherLastName, email: email, phone: phone, password: encryptedPassword, date: dateString, policyId: policyId, certificateId: certificateId).subscribe { event in
                switch event {
                case .next(let result):
                    observable.onNext(result)
                case .error(let error):
                    observable.onError(error)
                case .completed:
                    break
                }
            }
            return Disposables.create {
                disposable.dispose()
            }
        }
    }
    
    func validCertificate(_ certificate: String) -> TextFieldValidationState {
        if Util.validateCertificate(certificate) {
            return .valid(message: "")
        } else {
            return .invalid(message: LocalizableKeys.Profile.AddPolicy.Error.emptyCertificate)
        }
    }
    
    /**
     Realiza la peticion al servicio para agregar póliza
     - parameter policy
     */
    func addIndividualPolicy(policy: String) -> Observable<Bool> {
        return Observable.create { observable in
            let disposable = ServiceManager.addPolicy(newPolicy: policy, newCertificate: nil).subscribe({ event in
                switch event {
                case .next(let result):
                    observable.onNext(result)
                case .error(let error):
                    observable.onError(error)
                case .completed:
                    break
                }
            })
            
            return Disposables.create {
                disposable.dispose()
            }
        }
    }
    
    /**
     Realiza la peticion al servicio para agregar póliza
     - parameter policy
     - parameter certificate
     */
    func addCollectivePolicy(policy: String, certificate: String) -> Observable<Bool> {
        return Observable.create { observable in
            let disposable = ServiceManager.addPolicy(newPolicy: policy, newCertificate: certificate).subscribe({ event in
                switch event {
                case .next(let result):
                    observable.onNext(result)
                case .error(let error):
                    observable.onError(error)
                case .completed:
                    break
                }
            })
            
            return Disposables.create {
                disposable.dispose()
            }
        }
    }
    
}
